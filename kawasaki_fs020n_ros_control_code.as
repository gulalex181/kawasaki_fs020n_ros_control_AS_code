.PROGRAM autostart.pc()
    ; Порт серверного сокета
    .srv_port = 10050
    ; Версия (для совместимости)
    .version = 1040
    ; Флаг, что программа ros_move не работает
    ros_move_run = 0
    ; Флаг, что сервер работает в цикле
    ros_srv_run = 1
    WHILE ros_srv_run == 1 DO
        ; Активируем внутренний сигнал 2007
        SIGNAL 2007
        .sock_id = -1
        .listen = -1
        TCP_LISTEN .listen, .srv_port
        IF .listen > -1 THEN
            ; Принимаем запрос к порту .srv_port с ожиданием в 3 секунды
            TCP_ACCEPT .sock_id, .srv_port, 3
            ; Перестаем слушать новые соединения
            TCP_END_LISTEN .ret, .srv_port
        END
        ; Если произошла ошибка соединения
        IF .sock_id < 0 GOTO exit
        ; Если соединение установлено
        PRINT "ROS_SRV: Accepted inbound connection."
        ros_cmd[0, 1] = 0
        ; Индекс текущей команды 0 (никакой команды)
        ros_cmd_ind = 0
        ; Записываем ограничение скорости (1 == 100%)
        ros_speed_limit = 1
        ; Запускаем таймеры 1 и 2, начиная с 0
        TIMER(1) = 0
        TIMER(2) = 0
        .loop_run = 1
        WHILE .loop_run == 1 DO
        recv:
            .n = 1
            ; Читаем строку в массив .$buf (каждый элемент 255 байт)
            ; из сокета клиента с таймаутом в 5 секунд
            TCP_RECV .ret, .sock_id, .$buf[1], .n, 5
            ; Если произошла ошибка соединения
            IF .ret < 0 GOTO exit
            ; Если чтение прошло успешно
            .$data = .$buf[1]
            ; Читаем из полученной строки символы до первого пробела
            ; и преобразуем эту подстроку в действительное число.
            ; Получаем версию
            .ver = VAL($DECODE(.$data, " ", 0))
            IF .ver == .version THEN
                ; Удаляем все пробелы с начала строки до первого не пробела
                .$tp = $DECODE(.$data, " ", 1)
                ; Получаем команду
                .cmd = VAL($DECODE(.$data, " ", 0))
                ; Удаляем все пробелы с начала строки до первого не пробела
                .$tp = $DECODE(.$data, " ", 1)
                ; Получаем количество аргументов
                .arg = VAL($DECODE(.$data, " ", 0))
                ; В массиве ros_cmd будет храниться 16 последних поступивших
                ; команд с аргументами, 17-я и последующая будут затирать старые
                ; команды, начиная с начала массива
                .ind = (ros_cmd_ind + 1) MOD 16
                ; Сохраняем команду и количество аргументов в массив ros_cmd
                ros_cmd[.ind, 1] = .cmd
                ros_cmd[.ind, 2] = .arg
                FOR .i = 1 TO .arg
                    ; Удаляем все пробелы с начала строки
                    ; до первого не пробела
                    .$tp = $DECODE(.$data, " ", 1)
                    ; Добавляем в массив ros_cmd аргументы
                    ros_cmd[.ind, 2 + .i] = VAL($DECODE(.$data, " ", 0))
                END
                ; Запросы:  Структура массива ros_cmd:
                ;           |       |   1   |      2      |  3 |  4 |...|N - 2|
                ; RECV#1:   |   1   |COMMAND|COUNT_OF_ARGS|ARG1|ARG2|...|ARGN |
                ; RECV#2:   |   2   |COMMAND|COUNT_OF_ARGS|ARG1|ARG2|...|ARGN |
                ; ...
                ; RECV#15:  |   15  |COMMAND|COUNT_OF_ARGS|ARG1|ARG2|...|ARGN |
                ; RECV#16:  |   0   |COMMAND|COUNT_OF_ARGS|ARG1|ARG2|...|ARGN |
                ; RECV#17:  |   1   |COMMAND|COUNT_OF_ARGS|ARG1|ARG2|...|ARGN |
                CASE .cmd OF
                    ; ЗАПУСКАЕМ ПРОГРАММУ ros_move
                    ; ----------------------------
                    VALUE 1:
                        ; Если подано питание на двигатели, переключатель RUN/HOLD на панели контроллера
                        ; в состоянии RUN, переключатель TEACH/REPEAT на панели контроллера в состоянии
                        ; REPEAT и переключатель TEACH LOCK на пульте выключен
                        IF SWITCH(POWER) AND SWITCH(RUN) AND SWITCH(REPEAT) AND NOT SWITCH(TEACH_LOCK) THEN
                            ; Если задача Robot 1 не выполняется в данный момент и нет ошибок
                            IF TASK(1) <> 1 AND ERROR == 0 THEN
                                ; Флаг, что программа ros_move работает
                                ros_move_run = 1
                                ; Выполняем программу ros_move
                                ; (она будет работать одновременно с autostart.pc,
                                ; т.е. блокировки выполнения autostart.pc не будет)
                                MC EXEC ros_move ; ??? почему EXEC, а не EXECUTE (в мануале нет EXEC, кроме упоминания на стр. А-2)
                                ; ответ: можно сокращать команды до 4 символов 
                            END
                        END
                    ; ОСТАНАВЛИВАЕМ ПРОГРАММУ ros_move
                    ; --------------------------------
                    VALUE 2:
                        ; Активируем внутренний сигнал 2007 (тем самым завершаем программу ros_move)
                        SIGNAL 2007
                        ; Флаг, что программа ros_move не работает
                        ros_move_run = 0
                    ; УСТАНАВЛИВАЕМ КОНСОЛЬНУЮ СКОРОСТЬ И
                    ; ВКЛЮЧАЕМ ИСПОЛЬЗОВАНИЕ АБСОЛЮТНОЙ СКОРОСТИ
                    ; --------------------------------
                    VALUE 3:
                        ; Записываем ограничение скорости
                        ; (аргумент приходит в %, в ros_speed_limit пишем дробь)
                        ros_speed_limit = ros_cmd[.ind, 3] / 100
                        ; Устанавливаем ограничение консольной скорости
                        MC SPEED ros_cmd[.ind, 3]
                        ; Включаем использование абсолютной скорости
                        ABS.SPEED ON
                    ;VALUE 4:  ; MAXIMUM VELOCITY
                    ;    FOR .i = 1 TO 6
                    ;        ros_max_vel[.i] = ros_cmd[.ind, 2 + .i]
                    ;    END
                    ; ОТМЕНЯЕМ ТЕКУЩЕЕ ДВИЖЕНИЕ РОБОТА
                    ; --------------------------------
                    VALUE 5:
                        ; ??? зачем нужна такая команда
                        ; Если предыдущая команда не была такая же
                        IF ros_cmd[ros_cmd_ind, 1] <> 5 THEN
                            ros_cmd_ind = .ind ; ??? зачем нужна эта строка (возможно это строку можно удалить)
                            ; Останавливаем текущее движение робота
                            BRAKE
                        END
                    ; ЗАВЕРШАЕМ ТЕКУЩИЙ СЕАНС (РАЗРЫВАЕМ СОЕДИНЕНИЕ)
                    ; ----------------------------------------------
                    VALUE 255:
                        ; Устанавливаем переменную .loop_run в 0, что прервет цикл
                        .loop_run = 0
                END
                ; Сохраняем индекс текущей команды
                ros_cmd_ind = .ind
            END ; IF .ver == .version
            ; Сохраняем текущую позицию робота в массив .jt, где
            ; .jt[1] == JT1, .jt[2] == JT2, .jt[3] == JT3
            ; .jt[4] == JT4, .jt[5] == JT5, .jt[6] == JT6
            DECOMPOSE .jt[1] = #HERE
            ; Формируем строку ответа клиенту
            .$data = $ENCODE(.version, ERROR, SWITCH(RUN), SWITCH(REPEAT), SWITCH(TEACH_LOCK), SWITCH(POWER), TASK(1) == 1)
            .$data = .$data + $ENCODE(/F10.3, TIMER(1), .jt[1], .jt[2], .jt[3], .jt[4], .jt[5], .jt[6])
            ; Добавляем завершающий пробел
            .$buf[1] = .$data + " "
            ; Отправляем ответ клиенту с таймаутом 2 секунды
            TCP_SEND .ret, .sock_id, .$buf[1], 1, 2
            ; Если произошла ошибка соединения
            IF .ret < 0 GOTO exit
        END ; WHILE .loop_run == 1
    exit: ; сюда попадаем только в случае сетевой ошибки
        ; Активируем внутренний сигнал 2007 (тем самым завершаем программу ros_move)
        SIGNAL 2007
        ; Флаг, что программа ros_move не работает
        ros_move_run = 0
        ; Если есть соединение
        IF .sock_id > -1 THEN
            ; Закрываем соединение
            TCP_CLOSE .ret, .sock_id
            PRINT "ROS_SRV: Closed inbound connection."
        END
    END
.END

.PROGRAM ros_move()
    ; Деактивируем внутренний сигнал 2007
    SIGNAL -2007
    ; Мониторим сигнал 2007 (как появится идем к метке exit)
    ONI 2007 GOTO exit
    ; Настройки движения
    ; ------------------
    ; Включаем функцию непрерывного движения
    CP ON
    ; Устанавливаем точность позиции робота в 10 мм до
    ; следующей инструкции ACCURACY
    ACCURACY 10 ALWAYS
    ; 100%-й разгон до следующей инструкции ACCEL
    ACCEL 100 ALWAYS
    ; 100%-е торможение до следующей инструкции DECEL
    DECEL 100 ALWAYS
    ; 100%-я программная скорость до следующей инструкции SPEED
    SPEED 100 ALWAYS
    ; ------------------
    ; Сохраняем текущую позицию робота в массив .last_pt, где
    ; .last_pt[1] == JT1, .last_pt[2] == JT2, .last_pt[3] == JT3
    ; .last_pt[4] == JT4, .last_pt[5] == JT5, .last_pt[6] == JT6
    DECOMPOSE .last_pt[1] = #HERE
    ; Сохраняем текущее значение таймера #2
    .last_tm = TIMER(2)
    .step = 0
    WHILE ros_move_run == 1 DO
        ; При запуске программы ros_move командой 1:
        ; ------------------------------------------
        ; До тех пор пока не придет команда 6 или 7 цикл ros_move_run
        ; будет крутиться с командой 1, ничего не делая.
        ; 
        ; При уже запущенной программе ros_move:
        ; --------------------------------------
        ; Если цикл ros_move_run повторяется раньше, чем в ros_cmd_ind
        ; сохраняется индекс новой пришедшей команды (в autostart.pc),
        ; то будет повторена предыдущая команда, т.е. если это была команда 6
        ; или 7, то движение к той же точке, к которой робот либо двигается
        ; прямо сейчас, либо в которой он уже находится, а если это была другая
        ; команда, то цикл ros_move_run будет крутиться, ничего не делая, пока
        ; либо не появится команда 6 или 7, либо не будет завершена программа
        ; ros_move.
        ; 
        ; Если же цикл ros_move_run повторяется после того, как в ros_cmd_ind
        ; сохраняется индекс новой пришедшей команды (в autostart.pc),
        ; то будет выполняться новая команда, и робот будет двигаться в новую
        ; позицию.
        .ind = ros_cmd_ind
        .cmd = ros_cmd[.ind, 1]
        PRINT "ros_cmd_ind: ", ros_cmd_ind
        .arg = ros_cmd[.ind, 2]
        FOR .i = 1 TO .arg
            .args[.i] = ros_cmd[.ind, 2 + .i]
        END
        ; Сохраняем текущее значение таймера #2
        .tm = TIMER(2)
        CASE .cmd OF
            ; ДВИЖЕНИЕ РОБОТА С JOINT ИНТЕРПОЛЯЦИЕЙ В ЗАДАННУЮ ПОЗИЦИЮ
            ; --------------------------------------------------------
            VALUE 6:
                FOR .i = 1 TO 6
                    .pt[.i] = .args[3 + .i]
                END
                ; Движение робота с joint интерполяцией в позицию, где
                ; JT1 == .pt[1], JT2 == .pt[2], JT3 == .pt[3]
                ; JT4 == .pt[4], JT5 == .pt[5], JT6 == .pt[6]
                JMOVE #PPOINT(.pt[1], .pt[2], .pt[3], .pt[4], .pt[5], .pt[6])
            VALUE 7:  ; LMOVE
                ; ???
                .dt = MAXVAL(MINVAL(.tm - .args[1], 0.5), -0.5) + .args[2] * .step
                .new_pt = FALSE
                FOR .i = 1 TO 6
                    ; x = x0 + v*t + 0.5*a*t^2
                    ; ???
                    .pt[.i] = .args[3 + .i] + .dt * .args[9 + .i] + .dt * .dt * 0.5 * .args[15 + .i]
                    ; Если новое значение угла шарнира отличается от текущего
                    IF .pt[.i] <> .last_pt[.i] THEN
                        ; То ставим флаг, что есть новое значение угла шарнира
                        .new_pt = TRUE
                    END
                END
                ; Если есть новое значение угла любого шарнира
                IF .new_pt THEN
                    ; ???
                    IF ABS(.pt[3]) < 5 OR ABS(.pt[5]) < 5 THEN
                        SPEED 30
                        JMOVE #PPOINT(.pt[1], .pt[2], .pt[3], .pt[4], .pt[5], .pt[6])
                    ELSE
                        SPEED 0.1 S
                        LMOVE #PPOINT(.pt[1], .pt[2], .pt[3], .pt[4], .pt[5], .pt[6])
                    END
                END
                ; Сохраняем полученные значения углов шарниров как текущие значения
                FOR .i = 1 TO 6
                    .last_pt[.i] = .pt[.i]
                END
        END
        ; ???
        .step = .step * 0.9 + (.tm - .last_tm) * 0.1
        ; Сохраняем текущее значение таймера #2
        .last_tm = TIMER(2)
    END
exit: ; сюда попадаем только в случае возникновения сигнала 2007
.END